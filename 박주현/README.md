# 1️⃣일차 : 2025-01-13(MON)
<details>
  <summary>기획 준비</summary>

# 💡 비대면 면접 메이트

국내·외 기업의 취업 면접을 **비대면**으로 효율적으로 준비할 수 있는 서비스입니다.  
면접 스터디원 간 피드백을 간편하게 주고받을 수 있으며, **라이브 코딩 및 알고리즘** 문제 풀이 기능을 통해 **기술 면접**까지 대비할 수 있습니다.  

---

## 문제 상황

1. **국내 대기업 취업 준비 중인 지원자**  
   - 지방 거주로 인해 면접 스터디를 구하기 어려움  
   - 비대면 스터디 참여 시, 스터디원들이 대면 스터디에 비해 소극적이라고 느낌  
   - 스터디원 간 피드백 과정이 비효율적임

2. **해외 글로벌 IT 기업 취업 준비 중인 지원자**  
   - 영어로 자신의 생각을 명확히 표현하기 어려움  
   - 글로벌 면접에서 기대되는 태도와 답변 방식에 대한 정보 부족  
   - 라이브 코딩, 알고리즘 인터뷰에 대한 경험 부족  

---

## 핵심 기능

### 1. 비대면 면접 스터디
- **스터디 모집 및 매칭**  
  - 직무, 기술 스택, 경험 등 조건에 따라 그룹 생성  
- **피드백 관리**  
  - 채점 템플릿 제공: 스터디원들이 면접관 역할을 하며 객관적으로 평가  
  - 답변 텍스트화 & 코멘트 추가: 실시간 답변을 텍스트로 기록하고, 코멘트를 달아 피드백  
  - 피드백 취합 & 요약: AI가 여러 피드백을 자동으로 취합하여 개선점 요약  
- **영상 녹화 & 리뷰**  
  - 개인 면접 영상을 녹화 후, 비언어적 요소(표정, 시선, 제스처)까지 분석 가능  

### 2. 라이브 코딩 및 알고리즘 인터뷰 대비
- **Web IDE 제공**  
  - 온라인 상에서 알고리즘 문제(자료구조 구현, 알고리즘 풀이 등)를 연습  
- **풀이 과정 텍스트화**  
  - 풀이 과정 및 설명을 자동으로 텍스트화하여 시간대별 기록  
  - 자신의 논리 전개 흐름을 파악하고 피드백  
- **풀이 과정 설명 연습**  
  - 문제 해결 전략과 접근 방법을 연습할 수 있도록 가이드 제공  

### 3. 기출 질문 연습
- **질문당 답변 시간 측정**  
  - 면접과 유사한 환경에서 실전 감각 익히기  
- **AI 기반 답변 평가**  
  - 답변 논리성, 발음, 표현력 등 다각적인 분석  
- **답변 저장 & 비교**  
  - 이전 답변과 현재 답변을 비교하여 발전 상황 확인 가능  

---

## 유저 시나리오

### 국내 대기업 취업 준비 중인 지원자
1. **면접 대비 비대면 스터디 모집**  
   - “백엔드 개발자”, “Java/Spring Boot”, “신입/1년 경력” 조건으로 스터디 생성  
2. **스터디원들과 모의 면접 진행**  
   - 스터디원들이 돌아가며 면접관 및 지원자 역할을 수행  
   - 면접관 역할을 맡은 사람이 실시간으로 답변 텍스트화 및 코멘트 추가  
   - 면접 종료 후, AI가 스터디원 피드백을 종합하여 개선점 요약 (예: “말이 조금 빠르고, 논리적 흐름이 다소 부족함”)  
3. **면접 영상 리뷰**  
   - 녹화된 영상을 시청하며 표정, 시선 처리 등 비언어적 요소 확인  
   - AI 피드백을 통해 개선 포인트 파악 (예: “카메라 응시 빈도 낮음, 미소 부족”)  

### 해외 글로벌 IT 기업 취업 준비 중인 지원자
1. **비대면 면접 일정 확정**  
   - 글로벌 IT 기업에서 비대면 면접 일정 통보  
   - 영어 면접 대비를 위해 체계적 연습 필요  
2. **기출 질문 연습**  
   - “Tell me about yourself”, “Explain a complex project” 등 글로벌 기업 질문 연습  
   - AI 평가 및 피드백 예시  
     - 발음 명료성: 3/5 (발음을 천천히 하고, 강세 정확도 높이기)  
     - 답변 논리성: 4/5 (구체적 예시와 결과 추가 필요)  
   - 이전 답변과 비교해 점차 발전 과정을 추적  
3. **라이브 코딩 연습**  
   - Web IDE에서 “Two Sum”, “Binary Tree Traversal” 등 알고리즘 문제 풀이  
   - 풀이 과정 설명을 연습하며, 논리적 사고 흐름을 정리  
4. **최종 면접 대비**  
   - 기출 질문, 라이브 코딩 연습 결과와 AI 피드백을 토대로 보완  
   - 면접 당일, 자신감 있고 명확한 의사소통을 목표로 준비  

---
</details>

<details>
  <summary>JPA 복습 1일차 - JPA 기초 </summary>

### 객체 매핑
![image.png](./image.png)
- 매핑 정보를 표시하는 어노테이션 사용
    - @Entity, @id, @Column
### persistence.xml

- JPA 설정 정보
- META-INF/persistence.xml 클래스 패스 경로에 있으면 별도의 설정 없이 JPA가 인식함
- 일반적으로 영속성 유닛 (persistence-unit)은 연결할 데이터베이스당 하나 등록

<aside>
➕ 스프링 부트 사용 시 application.yml 사용

</aside>

### 데이터베이스 방언

- 방언 (dialect) : SQL 표준을 지키지 않거나 특정 데이터베이스만의 고유한 기능
- 특정 데이터베이스에 의존적인 SQL은 데이터베이스 방언이 처리해 줌 → 데이터베이스가 변경되어도 애플리케이션 코드 변경없이 데이터베이스 방언만 교체하면 됨

## 엔티티 매니저 설정


1. 엔티티 매니저 팩토리 생성
    
    ```java
    import javax.persistence.*;
    
    EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
    ```
    
    - persistence.xml의 설정 정보를 사용해서 엔티티 매니저 팩토리 생성
        - "jpabook"과 같은 이름을 기준으로 영속성 유닛 (persistence-unit) 찾아아서 엔티티 매니저 팩토리 생성
    - JPA를 동작시키기 위한 기반 객체 생성 + JPA 구현체에 따라서 데이터베이스 커넥션 풀도 생성 → 엔티티 매니저 팩토리 **생성 비용 아주 큼**
        - 애플리케이션 전체에서 한 번만 생성하고 공유해서 사용
2. 엔티티 매니저 생성
    
    ```java
    EntityManager em = emf.createEntityManager();
    ```
    
    - 엔티티 팩토리 매니저에서 엔티티 매니저 생성
    - JPA의 기능 대부분을 엔티티 매니저가 제공
        - 엔티티를 데이터베이스에 CRUD
        - 내부에 데이터소스(데이터베이스 커넥션)을 유지하면서 데이터베이스와 통신
    - 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용 하면 안됨
3. 종료
    - 사용이 끝난 엔티티 매니저는 반드시 종료
    - 엔티티 매니저 팩토리도 종료
    
    ```java
    em.close(); 
    emf.close();
    ```
    

## 트랜잭션 관리

- JPA를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야함
    - 아니면 예외 발생

```java
EntityTransaction tx = em.getTransaction();     
try {
				tx.begin(); //트랜잭션 시작
        logic(em);  //비즈니스 로직
        tx.commit();//트랜잭션 커밋
} catch (Exception e) {
        tx.rollback(); //트랜잭션 롤백
}
```

## 비즈니스 로직

```java
public interface EntityManager {
    void persist(Object var1);
    
    void remove(Object var1);

    <T> T find(Class<T> var1, Object var2);
    
    ...
}
```

- **등록** `em.persist()`
- **수정** `JPA가 추적`
- **삭제** `em.remove()`
- **조회** `em.find()`
    - 검색 쿼리?
        - 테이블이 아닌 엔티티 객체를 대상을 검색하려면 데이터베이스의 모든 데이터를 애플리케이션으로 불러와서 엔티티 객체로 변경 후 검색해야함 → 불가능
        - 필요한 데이터만 데이터베이스에서 불러오려면 SQL 사용해야함 → JPQL 사용

## JPQL

- JPA가 제공하는 SQL을 추상화한 객체지향 쿼리 언어
- SQL 문법과 거의 유사
- SQL과의 차이점

| JPQL                                                          | SQL                                                     |
| ------------------------------------------------------------- | ------------------------------------------------------- |
| 엔티티 객체를 대상으로 쿼리함 (클래스와 필드를 대상으로 쿼리함)<br>데이터베이스 테이블 전혀 알지 못함 | 데이터베이스 테이블을 대상으로 쿼리함                 |
| 대소문자 명확히 구분함                                        | 관례상 대소문자를 구분하지 않고 사용하는 경우 많음     |

</details>


# 2️⃣일차 : 2025-01-14(TUE)
<details>
  <summary>JPA 복습 2일차 - 영속성 관리</summary>

# 1. 엔티티 매니저 팩토리와 엔티티 매니저

### 엔티티 매니저 팩토리

- 생성 비용 큼
- 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유 가능
- 하이버네이트를 포함한 JPA 구현체들은 EntityManagerFactory 생성할 때 커넥션 풀 만듦 (J2SE환경)

### 엔티티 매니저

- 여러 스레드가 동시에 접근하면 동시성 문제 발생
- 데이터베이스 연결이 필요한 시점까지 커넥션을 얻지 않는다.
    - 보통 트랜잭션 시작할 때 커넥션 획득

# 2. 영속성 컨텍스트란?

### 영속성 컨텍스트(persistence context)

> 엔티티를 영구 저장하는 환경
> 
- 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리함
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어짐
- 엔티티 매니저를 통해 영속성 컨텍스트 접근, 관리 가능
- 여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수도 있다

# 3. 엔티티의 생명주기


### 엔티티의 상태

- **비영속(new/transient)** : 영속성 컨텍스트와 전혀 관계가 없는 상태
    - 객체 생성, 순수한 객체 상태
    - 영속성 컨텍스트나 데이터베이스와는 전형 관련 없음
- **영속(managed)** : 영속성 컨텍스트에 저장된 상태
    - 엔티티 매니저를 통해 저장(persist), 조회(find), JPQL 사용해서 조회한 엔티티
    - 영속성 컨텍스트에 의해 관리
- **준영속(detached)** : 영속성 컨텍스트에 저장되었다가 분리된 상태
    - 엔티티 매니저를 통해 detach, close, clear
    - 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 됨
- **삭제(removed)** : 삭제된 상태
    - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제

# 4. 영속성 컨텍스트의 특징

- 영속성 컨텍스트와 식별자 값
    - 영속성 컨텍스트는 엔티티를 식별자 값(@id)으로 구분
    - 영속 상태는 식별자 값이 반드시 존재
- 영속성 컨텍스트와 데이터베이스 저장
    - JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영 (플러시)
- 영속성 컨텍스트가 엔티티를 관리할 때의 장점
    - 1차 캐시
    - 동일성 보장
    - 트랜잭션을 지원하는 쓰기 지연
    - 변경 감지
    - 지연 로딩

## 4.1 엔티티 조회

### 1차 캐시 `장점1`

- 영속성 컨텍스트 내부의 캐시
- 영속상태의 엔티티는 모두 1차 캐시에 저장됨
- Map<식별자 값, 엔티티 인스턴스> 형태로 저장한다고 생각하면 됨
- 식별자 값은 데이터베이스 기본 키와 매핑되어 있으므로 영속성 컨텍스트에서 데이터를 저장하고 조회하는 모든 기준은 데이터베이스 기본 키 값이다.
- **성능상 이점 보장**
    - 예시) em.find()
        1. **1차 캐시에서 엔티티 조회**
            1. 1차 캐시에 있으면 → 4
            2. 1차 캐시에 없으면 → 2
        2. 데이터베이스를 조회해서 엔티티를 생성
        3. 1차 캐시에 저장
        4. 영속 상태의 엔티티 반환

### 영속 엔티티의 동일성 보장 `장점2`

- 식별자가 같은 엔티티 인스턴스를 조회하면 1차 캐시에 있는 같은 엔티티 인스턴스를 조회하므로 `a == b` 는 참이다.

<aside>
➕ JPA는 1차 캐시를 통해 반복 가능한 읽기 (REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다는 장점이 있다

</aside>

## 4.2 엔티티 등록

### 트랜잭션을 지원하는 쓰기 지연(transactional write-behind) `장점3`

- 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 쿼리를 모아두었다가 커밋할 때 모아둔 쿼리를 데이터베이스에 보냄
- 트랜잭션을 커밋하면
    1. 엔티티 매니저는 우선 영속성 컨텍스트를 플러시한다
        - **플러시(flush) : 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업**
        - 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보낸다
    2. 실제 데이터 베이스 트랜잭션을 커밋함

    
- 트랜잭션을 지원하는 쓰기 지연 가능한 이유? : 데이터 베이스에 쿼리를 바로 전달해도 트랜잭션을 커밋하지 않으면 소용 없음. 즉 커밋 직전에만 데이터베이스에 SQL을 전달하면 됨
- 쓰기 지연 이용해서 성능 최적화 가능

## 4.3 엔티티 수정

### 변경 감지(dirty checking) `장점4`

> 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능
> 
- JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해둠 (**스냅샷**)
- 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.
- 변경 감지 로직
    1. 트랜잭션을 커밋하면 엔티티 매니저 내부에서 플러시 호출
    2. 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다
    3. 변경된 엔티티가 있으며 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다
    4. 쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다
    5. 데이터베이스 트랜잭션 커밋
    ![image-1.png](./image-1.png)
    
    
- 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다
- JPA의 기본 전략은 엔티티의 모든 필드 업데이트
    - 장점
        - 모든 필드를 사용하면 수정 쿼리가 항상 같으므로 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용 가능
        - 데이터베이스는 이전에 한 번 파싱된 쿼리 재사용 가능
    - 단점
        - 데이터베이스에 보내는 데이터 전송량이 증가
    - 필드가 많거나 저장되는 내용이 너무 크면 동적으로 UPDATE SQL 생성하는 전략 (`@DynamicUpdate`) 사용하면 됨

<aside>
➕ 상황에 따라 다르지만 컬럼이 대략 30개 이상 되면 정적 수정 쿼리보다 동적 수정 쿼리가 빠름

- 한 테이블에 컬럼이 30개 이상 된다는 것은 테이블 설계상 책임이 적절하게 분리되지 않았을 가능성이 높음
</aside>

## 4.3 엔티티 삭제

- 엔티티를 삭제하려면 1. 삭제 대상 엔티티 조회 2. em.remove()
- em.remove()를 호출하는 순간 엔티티는 영속성 컨텍스트에서 제거됨
- 삭제된 엔티티는 재사용하지말고 자연스럽게 가비지 컬렉션의 대상이 되도록 두는 것이 좋다
</details>

<details>
  <summary>[피그마 특강 1일차] 기억할만한 팁</summary>

  ## 1. 피그마 파일 Thumbnail 설정 방법
- **Frame**에서 우클릭 → `Set as thumbnail` 선택
- 해당 Frame이 파일의 Thumbnail로 설정됨, 반영되는 데 딜레이 있음

---

## 2. 댓글(Comment) 남기기
- **@멤버이름**으로 멤버를 지정하면 해당 멤버에게 알림 전송 가능
- **주의사항**: 멤버를 지정하지 않을 경우, **모든 멤버에게 이메일로 알림 전송**

## 3. 피그마 파일 옮기기
- `Drafts` ↔ `Project` 간 **드래그 앤 드롭**으로 파일 이동 가능
- 작업하면서 흐름 끊기지 않고 파일 이동시키고 싶으면? : 피그마 작업 화면에서 파일명 우측 드롭다운 클릭 -> move

## 4. 피그마 히스토리 기능
- 파일명 우측 드롭다운 -> Show version history
- history 버전으로 묶어두는 것 가능

</details>

# 3️⃣일차 : 2025-01-15(WED)
<details>
  <summary>Toggle Content</summary>
  내용 3
</details>

# 4️⃣일차 : 2025-01-16(THU)
<details>
  <summary>Toggle Content</summary>
  내용 4
</details>

# 5️⃣일차 : 2025-01-17(FRI)
<details>
  <summary>Toggle Content</summary>
  내용 5
</details>

