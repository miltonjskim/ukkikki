
<details>
  <summary>
  <strong>1월 13일 월요일</strong>
  </summary>

# 다같이 쿡하자

## 문제 상황

1. **1인 가구 증가로 인한 고립감**
   - 혼자 요리하는 사람들이 늘어나고 있지만, 그 과정에서 외로움을 느끼고 있습니다.
   
2. **요리 초보자의 어려움**
   - 새로운 레시피에 도전하는 것에 대한 두려움이 있고, 어디서부터 시작해야 할지 몰라 요리를 기피하는 경우가 많습니다.
   
3. **실시간 피드백 부족**
   - 블로그나 영상 레시피는 많지만, 실시간으로 피드백을 받을 수 없어서 요리가 제대로 되고 있는지 확인하기 어려운 상황입니다.



## 시나리오

1. **가입 및 수준 설정**
   - 김영준은 **쿠게더**에 가입하여 자신의 요리 수준(초보자, 중급자, 상급자, 전문가)을 설정합니다.
   
2. **세션 신청**
   - 김영준은 **쿠게더**에서 사용자 B(전문가)가 진행하는 "도토리 국수 만들기" 실시간 세션에 참가 신청을 합니다. 세션은 2일 후에 열립니다.
   
3. **재료 준비**
   - 김영준은 호스트가 제공한 재료 목록을 확인하고, 쿠팡이나 다른 사이트와 연계하여 한 번에 재료를 구매할 수 있는 기능을 활용해 미리 구입합니다.
   
4. **실시간 세션 참여**
   - 세션 당일, 김영준은 실시간 화상 세션에 참여합니다.
   
5. **호스트의 재료 준비 확인**
   - 호스트 사용자 B는 각 참가자가 재료를 준비했는지 실시간으로 체크합니다. 예를 들어, "1. 재료 준비 2. 재료 썰기"와 같은 단계별로 진행 상황을 확인합니다.
   
6. **단계별 요리 진행**
   - 호스트는 각 단계에서 요리 진행을 설명하고, 참가자들이 이를 따라가도록 유도합니다. 각 단계마다 참가자들은 실시간으로 요리를 진행하며 피드백을 받습니다.
   
7. **실시간 피드백 요청**
   - 김영준은 요리 중 양념이 이상하다고 느끼고, 호스트에게 실시간 피드백을 요청합니다. 호스트는 김영준의 화면을 보고 소스를 추가할 것을 제안합니다.
   
8. **완성 후 피드백**
   - 김영준은 요리를 마친 후 커뮤니티에 완성된 사진을 올리고, 다른 참가자들로부터 피드백과 좋아요를 받으며 성취감을 느낍니다.
   
9. **세션 녹화 및 복습**
   - 세션은 녹화되어 김영준은 언제든지 요리 과정을 복습할 수 있습니다.



## 주요 기능

### 1. 사용자 관리
   - **개인 프로필**: 사용자는 자신이 관심 있는 요리 분야와 수준을 설정할 수 있습니다.
   - **맞춤형 세션 추천**: 사용자의 요리 수준에 맞춘 세션을 추천받을 수 있습니다.

### 2. 세션 관리
   - **세션 생성**: 호스트는 세션을 생성하며, 세션의 제목, 레시피 단계, 재료 목록, 시간, 참가비를 설정합니다.
   - **참가자 관리**: 참가자는 세션에 신청하고, 호스트는 이를 관리합니다.

### 3. 세션 일정 및 알림
   - **푸시 알림 및 이메일**: 세션 일정이 가까워지면 참가자에게 알림을 보냅니다.
   - **리마인더 기능**: 세션 시작 전 자동으로 리마인더 알림이 발송됩니다.

### 4. 레시피 공유 및 진행 상황 체크
   - **레시피 등록**: 호스트는 레시피를 1부터 10까지 단계별로 등록합니다.
   - **진행 상황 체크**: 참가자들은 각 단계별로 진행 상황을 체크하고, 호스트는 이를 확인하며 참가자들을 이끌어갑니다.

### 5. 실시간 채팅
   - 참가자는 실시간 채팅으로 호스트에게 피드백을 요청할 수 있습니다.
   - 호스트는 이를 확인한 후 화면을 보며 피드백을 제공합니다.

### 6. 실시간 요리 스트리밍
   - **실시간 비디오 통화**: 참가자들은 실시간으로 비디오 통화를 통해 서로의 요리 과정을 공유하고, 호스트는 이를 지도합니다.
   - **질문 및 피드백**: 참가자들은 요리 중 질문을 하고, 실시간으로 피드백을 받을 수 있습니다.



## 추가 기능

### 1. 결제 및 상거래
   - **세션 참가비 결제**: 전문가가 진행하는 실시간 세션에 대해 참가비를 결제하고, 이를 통해 수익 정산 기능이 제공됩니다.
   - **재료 구매 연동**: 호스트가 제공한 재료 목록을 손쉽게 연동된 쇼핑 사이트에서 구매할 수 있는 기능을 제공합니다.

---


<details>
  <summary>
  <strong>1월 14일 화요일</strong>
  </summary>

# WebRTC 학습 일지 - 브라우저로 실시간 통신하기

## WebRTC란?
Web Real-Time Communication의 약자인 WebRTC는 웹 브라우저 간 실시간 통신을 가능하게 하는 기술입니다. 플러그인 없이도 브라우저끼리 직접 통신할 수 있습니다.

## 주요 특징
브라우저 간 P2P 통신이 가능하고, 무료 오픈소스라서 누구나 사용할 수 있습니다. 
화상 통화나 파일 공유 등 다양한 용도로 활용할 수 있어요.

## 동작 방식 이해하기

1. 시그널링 (Signaling)
두 브라우저가 서로를 찾고 연결하기 위한 과정입니다. 마치 전화번호를 교환하는 것처럼 서로의 정보를 주고받습니다.

2. 연결 설정
ICE(Interactive Connectivity Establishment) 프레임워크를 사용해서 최적의 연결 경로를 찾습니다. STUN과 TURN 서버의 도움을 받아 NAT 환경에서도 연결이 가능합니다.

3. 통신 시작
실제로 미디어 스트림이나 데이터를 주고받는 단계입니다. RTCPeerConnection이라는 인터페이스를 통해 이루어집니다.

## 주요 특징
1. P2P 통신: 서버를 거치지 않고 브라우저 간 직접 연결이 이루어집니다. 이를 통해 낮은 지연 시간과 효율적인 데이터 전송이 가능합니다.

2. 미디어 스트림 지원: 비디오 및 오디오 통화를 기본적으로 지원합니다. 사용자는 브라우저만으로 화상 회의와 같은 실시간 커뮤니케이션을 구현할 수 있습니다.

3. 데이터 채널 지원: WebRTC는 파일 전송, 텍스트 메시지 전송 등의 데이터 전송 기능도 제공합니다. 이 데이터는 안정적으로 전송될 수 있도록 설계되었습니다.


4. 강력한 보안: WebRTC는 데이터 암호화 및 인증 메커니즘을 기본으로 제공합니다. 모든 전송되는 미디어와 데이터는 end-to-end 방식으로 암호화되어 안전합니다.

5. 네트워크 회피 기술: NAT(Network Address Translation)와 방화벽을 우회할 수 있는 기술이 내장되어 있어, 많은 환경에서도 안정적으로 연결이 가능합니다.

## 구현 기술

1. JavaScript: WebRTC API는 JavaScript로 구현되며, 브라우저 간의 실시간 통신을 제어합니다.

2. HTML5: HTML5를 통해 웹페이지에서 미디어 스트림을 표시하거나 관리할 수 있습니다.

3. STUN/TURN 서버: WebRTC는 NAT를 우회하는 기술이 필요한데, STUN과 TURN 서버를 사용하여 연결을 설정합니다. STUN 서버는 클라이언트의 공인 IP 주소를 찾고, TURN 서버는 중계 서버 역할을 합니다.

<details>
  <summary>
  <strong>1월 15일 수요일</strong>
  </summary>

# 공부 내용 
이번 프로젝트에서 시스템 모니터링과 성능 측정을 위해 Prometheus를 학습하였습니다.

# Prometheus

Prometheus는 오픈 소스 시스템 모니터링 및 알림 도구입니다.  
우리가 이를 사용하는 목적은 애플리케이션이나 시스템에서 발생하는 다양한 데이터를 시간에 따른 변화로 수집하고 저장하는 것입니다.  
이를 통해 애플리케이션의 성능을 분석하고 모니터링할 수 있습니다.

## 프로메테우스의 주요 기능

- **멀티-디멘셔널 데이터 모델**:  
  각 데이터(시간 시리즈)는 메트릭 이름과 키/값 쌍(label)으로 식별됩니다.

- **유연한 쿼리 언어: PromQL**:  
  데이터를 분석하고 시각화하기 위한 강력한 쿼리 언어입니다.

- **독립적인 저장 방식**:  
  분산 스토리지 없이도 단일 서버가 독립적으로 동작할 수 있습니다.

- **HTTP 기반 풀(Pull) 모델**:  
  데이터 수집 시 애플리케이션에서 데이터를 직접 가져오는 방식입니다.

- **푸시(Push) 방식 지원**:  
  임시 작업(예: 배치 작업)의 데이터를 푸시 게이트웨이를 통해 전달받을 수 있습니다.

- **서비스 디스커버리 및 정적 구성**:  
  데이터를 수집할 대상(target)을 자동으로 탐지하거나, 수동으로 구성할 수 있습니다.

- **그래프 및 대시보드 지원**:  
  수집한 데이터를 시각화할 수 있는 다양한 도구를 제공합니다(Grafana와 잘 연동됨).

## 메트릭(Metrics)이란?

메트릭은 숫자로 된 측정 값입니다.  
예를 들어, 웹 서버에서는 요청 처리 시간(request time)이 메트릭이 될 수 있고, 데이터베이스에서는 활성 연결(active connections)이나 활성 쿼리(active queries) 수가 메트릭이 될 수 있습니다.

시간 시리즈(Time Series)는 이러한 메트릭 값을 시간에 따라 기록하는 것을 의미합니다.  
예를 들어, 웹 애플리케이션이 느려지는 이유를 찾고 싶다면, 먼저 요청 수(request count)라는 메트릭을 살펴볼 수 있습니다.  
요청 수가 많아지면 애플리케이션이 느려질 가능성이 있으므로, 서버를 더 추가해 부하를 분산할 수 있습니다.

따라서 메트릭은 시스템이 어떻게 동작하고 있는지를 이해하는 데 핵심적인 역할을 합니다.

## 프로메테우스의 구성 요소

프로메테우스는 여러 가지 구성 요소로 이루어져 있으며, 필요에 따라 선택적으로 사용할 수 있습니다. 주요 구성 요소는 다음과 같습니다:

- **Prometheus 서버**  
  메트릭 데이터를 수집(scrape)하고 저장하며, 쿼리를 처리합니다.

- **클라이언트 라이브러리**  
  애플리케이션에 직접 메트릭 수집 로직을 추가하기 위한 라이브러리입니다.

- **푸시 게이트웨이(Push Gateway)**  
  단기 작업(예: 크론 작업)에서 데이터를 푸시(push) 방식으로 수집합니다.

- **익스포터(Exporter)**  
  HAProxy, StatsD, Graphite와 같은 서비스에서 메트릭을 수집하기 위한 도구입니다.

- **알림 관리자(Alertmanager)**  
  경고(alert)를 관리하고 알림을 보냅니다(예: 이메일, 슬랙).

- **시각화 도구**  
  Grafana와 같은 도구로 수집된 데이터를 시각화할 수 있습니다.

## 프로메테우스의 아키텍처

### Prometheus Server (프로메테우스 서버)
이 아키텍처의 핵심 컴포넌트입니다.  
프로메테우스 서버는 다음과 같은 역할을 수행합니다:
- **데이터 수집 (Retrieval)**: 모니터링 대상(target)에서 메트릭 데이터를 HTTP 프로토콜로 Pull(끌어오기) 방식으로 가져옵니다.
- **데이터 저장 (TSDB)**: 수집된 데이터를 **시간 시리즈 데이터베이스(Time Series Database)**에 저장합니다.
- **HTTP 서버**: 쿼리 언어(PromQL)를 통해 데이터를 조회하거나 외부 도구(Grafana 등)에서 데이터를 요청할 수 있도록 API를 제공합니다.

<details>
  <summary>
  <strong>1월 16일 목요일</strong>
  </summary>

# 자바 쓰레드
프로젝트에서 자바의 쓰레드를 활용해 멀티태스킹을 구현하고, 성능을 최적화 하는 방법을 적용해보기 위해 학습한 내용입니다.

## 프로세스
CPU 에서 실행 중인 프로그램(소프트웨어)로, CPU에게 메모리 공간을 할당받아 독립적으로 실행된다.

독립적인 실행 환경을 가짐.
서로 다른 프로세스는 독립적이지만, 상호작용이 가능함.
운영체제에서 각 프로세스는 고유한 메모리 공간을 할당받아 실행됨.

## 스레드
프로세스안에서 실질적으로 작업을 처리하는 단위.

- JVM에 의해 관리된다.
- 한개의 프로세스는 적어도 1개 이상을 가지고 있다.
- 모든 쓰레드는 동일한 프로세스의 리소스(메모리, 파일 등)를 공유함.
- 이로 인해 효율적인 자원 사용이 가능하지만, 여러 쓰레드가 동시에 리소스를 접근할 때 동기화 문제가 발생할 수 있음. 
- JAVA에서는 Main 스레드로 시작하여 다수의 스레드를 추가 생성하면 멀티 스레드 환경이 될 수 있다.

## 동기화란?
멀티스레드 환경에서 공유 자원에 대한 동시 접근을 제어하는 기법

여러 스레드가 동일한 자원에 동시에 접근할 때 발생할 수 있는 경쟁 상태(race condition)나 데이터 불일치를 방지

# 자바의 스레드 주요 메서드 ( 코드 분석)

## 1.  start() : 스레드 실행을 요청한다
```
public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
```

### `synchronized` 키워드
- `synchronized`는 임계 영역을 설정하는 키워드로, 한번에 하나의 스레드만 특정 메서드에 접근할 수 있도록 합니다. 이를 통해 스레드 간의 충돌을 방지하고 안전하게 데이터를 처리할 수 있습니다.

### `threadStatus != 0`
- 스레드의 상태가 0이 아니면 이미 스레드가 시작된 상태임을 의미합니다. 따라서 `start()` 메서드를 여러 번 호출하려 하면 예외가 발생하며, 스레드는 한 번만 시작할 수 있습니다.

### `group.add(this)`
- 현재 스레드가 속한 스레드 그룹에 자신을 추가하는 코드입니다. 스레드 그룹을 설정하지 않으면 기본적으로 `main` 그룹에 속하게 됩니다.

### `start0()`
- `start()` 메서드에서 호출되는 로우 레벨 메서드로, 실제로 스레드를 시작하는 작업을 처리합니다. 이는 JVM이 내부적으로 구현하며, 스레드를 실제로 실행하는 단계입니다.

### `started = true`
- `start0()`가 성공적으로 실행되면 `started`를 `true`로 설정합니다. 이는 스레드가 정상적으로 시작되었음을 나타냅니다.

### `finally` 블록
- `start0()` 호출 후에는 `finally` 블록이 실행됩니다. 만약 `start0()` 호출이 실패했다면, `group.threadStartFailed(this)`가 호출되어 스레드 시작 실패를 그룹에 알리게 됩니다.

## 2. interrupt() : 스레드 강제 종료
스레드를 즉시 중단하는 것이 아니라, JVM에게 중단 요청을 보낸다.

```
  public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }
```

### `this != Thread.currentThread()`
- 현재 스레드가 자기 자신을 `interrupt` 하는 것이 아니라면 보안검사를 수행합니다. 즉, 다른 스레드가 인터럽트를 시도하는 경우에만 추가적인 보안 처리가 이루어집니다.

### `blockerLock`
- `blockerLock`은 위 코드에서 임계 영역을 보호하기 위해 사용되는 락 객체입니다. 이를 통해 여러 스레드가 동시에 해당 영역에 접근하지 못하도록 방지합니다.

### `blocker`가 존재하면:
1. `interrupt0()`로 인터럽트 플래그를 설정합니다.
2. `blocker`의 `interrupt()` 메소드를 호출하여 차단된 스레드에 인터럽트를 발생시킵니다.
3. 메소드가 종료됩니다.


