# 자바 쓰레드
프로젝트에서 자바의 쓰레드를 활용해 멀티태스킹을 구현하고, 성능을 최적화 하는 방법을 적용해보기 위해 학습한 내용입니다.

## 프로세스
CPU 에서 실행 중인 프로그램(소프트웨어)로, CPU에게 메모리 공간을 할당받아 독립적으로 실행된다.

독립적인 실행 환경을 가짐.
서로 다른 프로세스는 독립적이지만, 상호작용이 가능함.
운영체제에서 각 프로세스는 고유한 메모리 공간을 할당받아 실행됨.

## 스레드
프로세스안에서 실질적으로 작업을 처리하는 단위.

- JVM에 의해 관리된다.
- 한개의 프로세스는 적어도 1개 이상을 가지고 있다.
- 모든 쓰레드는 동일한 프로세스의 리소스(메모리, 파일 등)를 공유함.
- 이로 인해 효율적인 자원 사용이 가능하지만, 여러 쓰레드가 동시에 리소스를 접근할 때 동기화 문제가 발생할 수 있음. 
- JAVA에서는 Main 스레드로 시작하여 다수의 스레드를 추가 생성하면 멀티 스레드 환경이 될 수 있다.

## 동기화란?
멀티스레드 환경에서 공유 자원에 대한 동시 접근을 제어하는 기법

여러 스레드가 동일한 자원에 동시에 접근할 때 발생할 수 있는 경쟁 상태(race condition)나 데이터 불일치를 방지

# 자바의 스레드 주요 메서드 ( 코드 분석)

## 1.  start() : 스레드 실행을 요청한다
```
public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
```

### `synchronized` 키워드
- `synchronized`는 임계 영역을 설정하는 키워드로, 한번에 하나의 스레드만 특정 메서드에 접근할 수 있도록 합니다. 이를 통해 스레드 간의 충돌을 방지하고 안전하게 데이터를 처리할 수 있습니다.

### `threadStatus != 0`
- 스레드의 상태가 0이 아니면 이미 스레드가 시작된 상태임을 의미합니다. 따라서 `start()` 메서드를 여러 번 호출하려 하면 예외가 발생하며, 스레드는 한 번만 시작할 수 있습니다.

### `group.add(this)`
- 현재 스레드가 속한 스레드 그룹에 자신을 추가하는 코드입니다. 스레드 그룹을 설정하지 않으면 기본적으로 `main` 그룹에 속하게 됩니다.

### `start0()`
- `start()` 메서드에서 호출되는 로우 레벨 메서드로, 실제로 스레드를 시작하는 작업을 처리합니다. 이는 JVM이 내부적으로 구현하며, 스레드를 실제로 실행하는 단계입니다.

### `started = true`
- `start0()`가 성공적으로 실행되면 `started`를 `true`로 설정합니다. 이는 스레드가 정상적으로 시작되었음을 나타냅니다.

### `finally` 블록
- `start0()` 호출 후에는 `finally` 블록이 실행됩니다. 만약 `start0()` 호출이 실패했다면, `group.threadStartFailed(this)`가 호출되어 스레드 시작 실패를 그룹에 알리게 됩니다.

## 2. interrupt() : 스레드 강제 종료
스레드를 즉시 중단하는 것이 아니라, JVM에게 중단 요청을 보낸다.

```
  public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }
```

### `this != Thread.currentThread()`
- 현재 스레드가 자기 자신을 `interrupt` 하는 것이 아니라면 보안검사를 수행합니다. 즉, 다른 스레드가 인터럽트를 시도하는 경우에만 추가적인 보안 처리가 이루어집니다.

### `blockerLock`
- `blockerLock`은 위 코드에서 임계 영역을 보호하기 위해 사용되는 락 객체입니다. 이를 통해 여러 스레드가 동시에 해당 영역에 접근하지 못하도록 방지합니다.

### `blocker`가 존재하면:
1. `interrupt0()`로 인터럽트 플래그를 설정합니다.
2. `blocker`의 `interrupt()` 메소드를 호출하여 차단된 스레드에 인터럽트를 발생시킵니다.
3. 메소드가 종료됩니다.
