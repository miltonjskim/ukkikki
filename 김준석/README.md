
<details>
  <summary>
  <strong>1월 13일 월요일</strong>
  </summary>

# 프로젝트 기획안
## 문제 상황

- 여자 친구와 붓글씨 클래스를 가고 싶은 지방에 거주하는 27세 영준이.
    - 가장 가까운 클래스를 검색해보니 100km나 걸리는 절망적인 상황
    - 아 그냥 온라인으로 들을 순 없나?
    - 그런데 몰입도가 떨어지면 어떡하지?
    - 녹화 강의를 듣자니 질문을 곧바로 할 수도 없고..
- 지방에 거주하는 폴 댄스 강사 겸 플로리스트 27세 규현이.
    - 폴 댄스 학원을 차렸더니 지방이라 그런지 수강생이 저조
    - 플로리스트도 하고 있어 그 재능도 살리고 싶지만 폴 댄스 학원에서 꽃꽂이를 강의하기엔 애매한 상황
    - 적은 공간에서 둘 다를 강의할 순 없을까?

## 해결 방안

- 강사와 수강생을 연결하는 온라인 강의
- 수강생의 강의 몰입도를 높이기 위한 실시간 퀴즈, 설문 등의 장치

## 주요 기능

- 강사와 수강생을 연결하는 실시간 화상 클래스
    - 수강생 출석 확인 기능
    - 강사의 실시간 퀴즈 제시 및 수강생의 답안 제출
    - 실시간 설문조사
- 카테고리 별 강의 검색 기능
- 수강생의 수강 목록을 분석해 맞춤형 강의 추천
- 강의 다시보기 기능
- 클래스 후 후속 질의응답 게시판
- 수강생의 수요와 선호도를 강사에게 제공

---

# WebRTC란 무엇인가?

WebRTC(Web Real-Time Communication)는 웹 브라우저 및 모바일 애플리케이션에서 **플러그인 없이 실시간 음성, 영상 및 데이터 통신**을 가능하게 하는 기술입니다. Google에서 시작한 이 기술은 W3C와 IETF의 표준화 작업을 거쳐 현재 다양한 브라우저와 플랫폼에서 지원됩니다.

## **WebRTC의 주요 구성 요소**

1. **Peer-to-Peer 연결**
    - WebRTC는 브라우저 간 직접 연결(Peer-to-Peer)을 통해 낮은 지연 시간과 효율적인 데이터 전송을 제공합니다.
2. **미디어 스트림 처리**
    - 실시간으로 음성/영상 데이터를 캡처, 전송, 렌더링.
3. **데이터 채널**
    - 파일 공유 및 게임 등 다양한 응용 프로그램에서 사용 가능한 **텍스트/바이너리 데이터** 전송.
4. **NAT Traversal**
    - STUN(Traversal Using Relays around NAT) 및 TURN(Traversal Using Relays around NAT)을 사용해 방화벽 및 NAT(Network Address Translation)를 우회.

---

# WebRTC 서버에 적용 시 고려 사항

WebRTC는 Peer-to-Peer 연결을 지향하지만, 실질적으로 서버가 중재 역할을 해야 할 경우가 많습니다. 이를 고려해 다음 사항들을 설계해야 합니다:

## 1. **시그널링 (Signaling)**

- WebRTC는 연결을 설정하기 위해 **시그널링 프로토콜**이 필요합니다.
- **역할**:
    - 연결 초기화 (SDP(Session Description Protocol) 교환)
    - 네트워크 정보(IP/포트) 교환
    - ICE(Interactive Connectivity Establishment) 후보 교환
- **기술**:
    - WebSocket, HTTP, Socket.IO 등.

## 2. **STUN/TURN 서버**

- **STUN 서버**: 클라이언트가 공인 IP 주소를 확인하고 Peer-to-Peer 연결을 설정하는 데 사용.
- **TURN 서버**: NAT/방화벽으로 인해 직접 연결이 불가능할 경우 데이터를 중계.
- TURN 서버를 구축할 경우 성능 및 비용 고려 필요.

## 3. **확장성**

- 다수의 사용자가 동시에 접속할 경우, Peer-to-Peer만으로는 한계가 있습니다.
    - **SFU(Selective Forwarding Unit)**: 클라이언트가 전송한 데이터를 중계하며, 선택적으로 전달.
    - **MCU(Multipoint Control Unit)**: 데이터를 수집하고 처리한 후 클라이언트에 전달.
- 예: Jitsi, Mediasoup, Janus 등.

## 4. **보안**

- 모든 WebRTC 통신은 암호화가 기본.
    - DTLS-SRTP (Datagram Transport Layer Security - Secure Real-time Transport Protocol)를 사용.
- 시그널링 서버와 TURN 서버의 통신도 HTTPS 또는 WSS(WebSocket Secure)로 보호.
- 네트워크 방화벽 및 DoS/DDoS 공격 방지 대책 필요.

## 5. **브라우저 호환성**

- WebRTC는 다양한 브라우저에서 작동하지만, 일부 기능은 브라우저 간 동작 방식이 다를 수 있습니다.
- 크로스 브라우저 테스트 필요.

## 6. **네트워크 상태**

- 네트워크 대역폭 및 품질에 따라 동영상 해상도와 전송 속도 조정.
- WebRTC는 `RTCPeerConnection.getStats()`를 통해 네트워크 상태를 모니터링 가능.

## 7. **로그 및 디버깅**

- WebRTC 트래픽 및 연결 문제를 디버깅하기 위해 로그 시스템 구성.
- WebRTC-internals(크롬 개발자 도구) 활용.
</details>



<details>
<summary>
  <strong>1월 14일 화요일</strong>
</summary>

# CDN (Content Delivery Network), 미디어 서버

## CDN (Content Delivery Network)

### 정의
CDN은 전 세계에 분산된 서버 네트워크로, 사용자와 가장 가까운 서버에서 콘텐츠를 제공하여 성능을 최적화하고 지연 시간을 줄이는 역할을 수행

### 특징
1. **빠른 콘텐츠 전송**: 사용자와 가까운 엣지 서버에서 데이터를 전송하여 로드 시간을 단축
2. **부하 분산**: 원본 서버의 요청을 분산시켜 서버 과부하를 방지
3. **확장성**: 대규모 트래픽을 처리할 수 있도록 설계
4. **보안 강화**: DDoS 방어 및 SSL/TLS를 통해 안전한 전송 보장

### 사용 사례
- 정적 콘텐츠 제공: HTML, CSS, JavaScript, 이미지, 동영상 등
- 동적 콘텐츠 캐싱: API 응답, 사용자 맞춤형 데이터
- 라이브 스트리밍: 실시간 이벤트의 안정적인 전달

### WebRTC와의 연계
CDN은 WebRTC 기반 서비스에서 다음과 같은 방식으로 활용됨됨:
- **TURN 서버와 병행 사용**: P2P 연결이 불가능한 경우 TURN 서버와 CDN이 연계되어 데이터 전송을 지원
- **STUN 서버 초기화 지원**: WebRTC의 연결 설정을 빠르게 수행하기 위해 사용
- **미디어 리소스 제공**: WebRTC 서비스 내에서 사용되는 정적 파일 및 미디어를 빠르게 전송

## 미디어 서버

### 정의
미디어 서버는 실시간 또는 요청 기반으로 오디오, 비디오 데이터를 처리하고 스트리밍하는 서버. 
WebRTC와 결합하여 대규모 실시간 통신 서비스의 핵심 역할을 수행

### 주요 기능
1. **미디어 처리**: 오디오 및 비디오 트랜스코딩, 믹싱, 분배
2. **방송 및 녹화**: 실시간 스트리밍과 기록된 콘텐츠를 제공
3. **다자간 연결**: SFU(Selective Forwarding Unit) 또는 MCU(Multipoint Control Unit)를 통해 그룹 통화 지원

### 유형
- **SFU (Selective Forwarding Unit)**
  - 다자간 통신에서 각 사용자의 미디어 스트림을 선택적으로 전달
  - 효율적이며 대규모 사용자 환경에 적합
- **MCU (Multipoint Control Unit)**
  - 모든 미디어 스트림을 중앙 서버에서 처리 후 통합된 스트림을 각 사용자에게 전달
  - 서버 부하가 크지만 클라이언트의 처리 요구사항 감소

### WebRTC와의 연계
미디어 서버는 WebRTC의 P2P 통신을 확장해 다음과 같은 기능을 가능케 함
- **대규모 그룹 통화**: SFU를 통해 개별 사용자 스트림을 효율적으로 관리
- **녹화 및 재생**: 통화 내용이나 라이브 스트림 저장
- **QoS (Quality of Service)**: 대역폭 및 네트워크 조건에 따라 스트림 품질 조정

### 구현 시 고려사항
1. **네트워크 환경**: 서버와 클라이언트 간 레이턴시를 최소화하는 인프라 설계
2. **확장성**: 사용자가 증가할 경우 수평적 확장을 지원
3. **보안**: 데이터 암호화 및 인증 메커니즘 적용
4. **호환성**: 다양한 디바이스와 브라우저 지원

## CDN과 미디어 서버 통합 전략

### WebRTC 프로젝트에서의 통합
1. **CDN 활용**:
   - 정적 콘텐츠(예: 미디어 파일, 스크립트) 전송을 최적화
   - TURN 서버를 통해 전송 불가한 WebRTC 데이터를 지원

2. **미디어 서버 역할**:
   - 실시간 통신 관리
   - 사용자 수에 따라 SFU/MCU 선택

3. **혼합 아키텍처**:
   - 정적 데이터는 CDN, 실시간 데이터는 미디어 서버로 처리

### 설계 시 고려사항
- 사용자 위치에 따라 적합한 CDN 노드 선택
- 미디어 서버의 로드 밸런싱 및 장애 조치(failover) 설계
- 실시간 데이터와 캐싱 가능한 데이터의 명확한 분리

</details>


<details>
  <summary>
  <strong>1월 15일 수요일</strong>
  </summary>

# CDN과 Socket의 아키텍처

## 1. CDN (Content Delivery Network)

### 1.1 구성 요소
1. **오리진 서버 (Origin Server)**  
   - 웹 콘텐츠(HTML, CSS, JS, 이미지 등)의 원본을 저장
   - CDN은 오리진 서버로부터 콘텐츠를 복사하여 전송
   
2. **캐시 서버 (Edge Server)**  
   - 사용자와 지리적으로 가까운 위치에 콘텐츠를 캐싱
   - 요청을 처리하며, 필요한 경우 오리진 서버와 통신
   
3. **DNS (Domain Name System)**  
   - 사용자의 요청을 가장 가까운 Edge Server로 라우팅
   
4. **Load Balancer**  
   - 요청 부하를 여러 캐시 서버로 분산하여 성능 최적화
   
---

### 1.2 작동 원리
1. 사용자가 웹 리소스를 요청하면 DNS를 통해 가장 가까운 Edge Server로 연결
2. **Edge Server**가 요청된 콘텐츠를 캐싱하고 사용자에게 응답
3. 캐시가 만료되었거나 콘텐츠가 없는 경우, Edge Server는 오리진 서버에서 데이터를 가져옴
4. 가져온 콘텐츠를 캐싱 후 사용자에게 전달

---

## 2. Socket

### 2.1구성 요소
1. **클라이언트**  
   - 데이터를 요청하거나 송신하는 장치나 애플리케이션
   
2. **서버**  
   - 클라이언트의 요청을 수신하고 데이터를 응답
   
3. **Socket 연결**  
   - 클라이언트와 서버 간의 네트워크 연결
   - 연결은 IP와 Port를 통해 이루어짐

4. **프로토콜**  
   - **TCP (Transmission Control Protocol)**: 안정적이고 순서가 보장된 데이터 전송
   - **UDP (User Datagram Protocol)**: 빠른 전송, 순서 보장이 필요 없는 데이터 전송

---

### 2.2 작동 원리
1. **Socket 생성**  
   - 클라이언트와 서버가 각각 소켓을 생성
2. **연결 요청**  
   - 클라이언트가 서버의 소켓에 연결 요청을 보냄
3. **연결 수립**  
   - 서버가 요청을 수락하고 연결을 설정
4. **데이터 송수신**  
   - 양방향 데이터 통신이 시작
5. **연결 종료**  
   - 작업 완료 후 소켓 연결이 종료

---

### 2.3 WebSocket과의 차이
- WebSocket은 HTTP 프로토콜 위에서 동작하며, 초기 연결 이후 **풀 이중 통신**을 제공
- 일반적인 Socket은 TCP/UDP 기반으로 더 저수준의 네트워크 통신을 다룸

---
</details>

<details>
  <summary>
  <strong>1월 16일 목요일</strong>
  </summary>

   # Document 형 NoSQL DB 활용 전략

## 1. Document 형 NoSQL DB란?
Document 형 데이터베이스는 데이터를 JSON, BSON, XML과 같은 문서 형태로 저장하며, 유연한 데이터 모델과 높은 확장성을 제공하는 NoSQL의 한 유형입니다. 대표적인 Document 형 DB로는 MongoDB, Couchbase 등이 있습니다.

### 주요 특징
- **스키마리스 데이터 모델**: 데이터 구조가 유연하여 스키마 변경 없이 새로운 필드를 추가할 수 있음.
- **계층적 데이터 표현**: 문서 내부에 중첩된 데이터를 포함하여 복잡한 객체를 저장 가능.
- **수평 확장성**: 샤딩과 복제를 통한 성능 향상 및 가용성 보장.
- **빠른 읽기/쓰기 성능**: 대규모 트랜잭션 처리에 적합.

---

## 2. Document 형 NoSQL DB 활용 방안

### 2.1 애플리케이션 사례
#### 1) **실시간 애플리케이션**
   - **챗봇 및 메시징 서비스**: 빠른 읽기/쓰기 성능을 활용하여 실시간 대화 데이터를 저장.
   - **IoT 데이터 처리**: 센서에서 수집되는 대량의 데이터 스트림 처리.

#### 2) **콘텐츠 관리**
   - **블로그 및 CMS 플랫폼**: 다양한 형식의 콘텐츠를 문서로 저장하여 빠르게 검색 및 제공.
   - **전자상거래**: 상품 정보(이미지, 설명, 속성 등)와 주문 데이터를 유연하게 관리.

#### 3) **데이터 분석**
   - 로그 수집 및 분석: 다양한 이벤트 데이터를 문서로 저장하여 분석.
   - 사용자 행동 추적: 개인화된 경험 제공을 위한 데이터 활용.

### 2.2 설계 시 고려사항
- **데이터 모델링**: 문서 단위의 CRUD 작업이 효율적이도록 설계.
  - 관계형 데이터는 내장(Nested) 문서를 사용하거나 참조 방식으로 저장.
- **인덱싱 전략**: 자주 쿼리되는 필드에 적절한 인덱스를 생성하여 성능 최적화.
- **스케일링**:
  - 읽기 성능 향상: 복제(replication)를 통해.
  - 쓰기 성능 향상: 샤딩(sharding)을 통해.
- **백업 및 복구 계획**: 정기적인 스냅샷 및 트랜잭션 로그 백업 수행.

---

# InnoDB의 Index 전략

## 1. InnoDB란?
InnoDB는 MySQL의 기본 스토리지 엔진으로, 높은 성능과 안정성을 제공하며 ACID 트랜잭션을 지원합니다. 주요 특징 중 하나는 강력한 인덱스 관리 기능입니다.

### 주요 특징
- **클러스터드 인덱스(Clustered Index)**
  - 테이블의 기본 키를 기반으로 데이터가 물리적으로 정렬되어 저장.
  - 클러스터드 인덱스가 없는 경우 InnoDB는 내부적으로 생성한 Row ID를 사용.

- **보조 인덱스(Secondary Index)**
  - 보조 인덱스의 엔트리는 기본 키를 통해 데이터를 참조.
  - 보조 인덱스를 활용한 쿼리는 추가적인 기본 키 조회가 필요하므로 클러스터드 인덱스보다 느릴 수 있음.

---

## 2. InnoDB Index 활용 전략

### 2.1 인덱스 종류
- **B-Tree 인덱스**: 일반적으로 사용되는 인덱스 유형으로, 범위 쿼리 및 정렬에 효율적.
- **Full-Text 인덱스**: 텍스트 데이터에 대한 검색에 최적화.
- **Spatial 인덱스**: 공간 데이터를 처리하는 데 사용.

### 2.2 설계 원칙
#### 1) **클러스터드 인덱스 최적화**
- **적절한 기본 키 선택**
  - 기본 키는 고유하며 짧고 안정적이어야 함.
  - 너무 길거나 자주 변경되는 열은 기본 키로 적합하지 않음.
- **자주 조회되는 데이터**는 기본 키로 설계하여 성능 향상.

#### 2) **보조 인덱스 설계**
- **쿼리 패턴 분석**: 자주 사용되는 WHERE 조건, JOIN, ORDER BY 절의 열에 인덱스를 생성.
- **커버링 인덱스 활용**: 쿼리에서 필요한 모든 데이터를 인덱스만으로 처리할 수 있도록 설계.

#### 3) **인덱스 수 제한**
- 인덱스가 많아질수록 쓰기 작업의 성능 저하 발생.
- 자주 사용되지 않는 인덱스는 제거.

### 2.3 유지 및 관리
- **분석 도구 활용**
  - `EXPLAIN`을 사용하여 쿼리 성능 점검.
  - `SHOW INDEX`로 테이블의 인덱스 상태 확인.
- **통계 업데이트**
  - `ANALYZE TABLE` 명령으로 최신 통계 유지.
- **프래그먼테이션 관리**
  - 인덱스와 테이블의 조각화를 방지하기 위해 정기적으로 `OPTIMIZE TABLE` 실행.

---

## 3. 성능 튜닝 사례
### 사례 1: 느린 쿼리 해결
1. 쿼리 로그 분석.
2. 인덱스 부재 또는 비효율적인 인덱스를 확인.
3. 적절한 인덱스 추가로 응답 속도 개선.

### 사례 2: 대량 데이터 삽입
1. 인덱스 비활성화 후 데이터 삽입.
2. 삽입 후 인덱스 다시 활성화.
3. 트랜잭션 단위를 설정하여 성능 향상.

---

## 결론
Document 형 NoSQL DB와 InnoDB는 각자의 강점과 사용 사례에 따라 적합한 선택을 해야 합니다. Document DB는 유연성과 확장성이 필요한 애플리케이션에, InnoDB는 트랜잭션 안전성과 정교한 인덱스 관리가 필요한 경우에 이상적입니다. 효과적인 데이터베이스 설계와 성능 튜닝은 성공적인 시스템 운영의 핵심입니다.


 </details> 
